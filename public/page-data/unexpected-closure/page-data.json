{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/unexpected-closure/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Alex Figueroa","social":[{"name":"twitter","url":"https://twitter.com/externconst"},{"name":"github","url":"https://github.com/ajfigueroa"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"4bbdc643-0779-5fd9-83e5-a9d7ee60b104","excerpt":"Closures in Swift are a great feature and are useful for tasks such as network callbacks, notification subscription, and providing anâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unexpected Closure\",\n  \"date\": \"2018-09-04T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Closures in Swift are a great feature and are useful for tasks such as network callbacks, notification subscription, and providing an alternative to the delegate pattern.\"), mdx(\"p\", null, \"Recently, I discovered that code as inconspicuous as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \" (and) conditional could also leverage this feature.\"), mdx(\"p\", null, \"Let\\u2019s assume that we are modelling a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" of a global subscription-based application where users can customize their theme color.\"), mdx(\"p\", null, \"We could represent this in Swift as a struct that has properties for its: identifier, subscription status, country code, and theme color.\\nThe resulting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" model could look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"struct User {\\n    var id: String\\n    var isSubscribed: Bool\\n    var themeColor: UIColor?\\n    var countryCode: String\\n}\\n\")), mdx(\"p\", null, \"We\\u2019ll make the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"themeColor\"), \" optional here since it\\u2019ll be up to the User if they want to customize this.\"), mdx(\"p\", null, \"Assume that our application already had an object to represent a theme called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Theme\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"class Theme {\\n    let backgroundColor: UIColor\\n\\n    init(backgroundColor: UIColor?) {\\n        self.backgroundColor = backgroundColor ?? .white\\n    }\\n}\\n\")), mdx(\"p\", null, \"Observe that this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" will fallback to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIColor.white\"), \" (or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".white\"), \") if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"backgroundColor\"), \" property is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" provided.\"), mdx(\"p\", null, \"Given this knowledge, we could create a new class just for the custom User theme.\\nWe can initialize the custom theme with a User in order to grab its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"themeColor\"), \". The theme color passes to its parent class as its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"backgroundColor\"), \".\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Theme\"), \" subclass can represent the custom User theme object:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"class UserTheme: Theme {\\n    let user: User\\n\\n    init(user: User) {\\n        self.user = user\\n        super.init(backgroundColor: user.themeColor)\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let\\u2019s assume that we have received additional requirements that limit User theming to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"subscription users\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Canadian users\")), mdx(\"p\", null, \"We could then update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserTheme\"), \" to handle these cases as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"var themeColor: UIColor?\\nif self.user.isSubscribed && self.user.countryCode == \\\"CA\\\" {\\n    themeColor = self.user.themeColor\\n}\\nsuper.init(backgroundColor: themeColor)\\n\")), mdx(\"p\", null, \"Although this looks alright, it\\u2019ll actually fail to compile. You\\u2019ll see the following error log in Xcode:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"error: 'self' captured by a closure before all members were initialized\\n        if self.user.isSubscribed && self.user.countryCode == \\\"CA\\\" {\\n                                     ^\\n\")), mdx(\"p\", null, \"This error message while informative is a bit confusing. What closure is it referencing?\"), mdx(\"p\", null, \"We could easily fix by removing the explicit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" and instead rely on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" property passed in as a parameter. This fixes the symptom and not the root cause which is that there is an implicit closure in this line of code?\"), mdx(\"p\", null, \"After posting this error message to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.meetup.com/tacow-org/\"\n  }), \"tacow\"), \" Slack group, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/rydermackay\"\n  }), \"@rydermackay\"), \" pointed out to me that the Swift language is capturing the right-hand side of the conditional in a closure.\"), mdx(\"p\", null, \"That is, given the conditional: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lhs && rhs\"), \" (\\u201Clhs\\u201D and \\u201Crhs\\u201D represent Left-Hand Side and Right-Hand Side respectively). \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rhs\"), \" is being wrapped in a closure. More specifically, it is wrapped in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"autoclosure\"), \" so that it could lazily evaluate the right condition if the left condition was false.\"), mdx(\"p\", null, \"This can be shown by looking at the source code for the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/apple/swift/blob/7f105e4e3a994e6ac87860d5bd7bf9942c52b4bb/stdlib/public/core/Bool.swift#L289\"\n  }), \"&& operator\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"public static func && (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows -> Bool {\\n    return lhs ? try rhs() : false\\n}\\n\")), mdx(\"p\", null, \"In order to understand the warning a little better, we need to know what an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"autoclosure\"), \" is.\"), mdx(\"p\", null, \"From the Apple documentation, an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"autoclosure\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u2026is a closure that is automatically created to wrap an expression that\\u2019s being passed as an argument to a function. It doesn\\u2019t take any arguments, and when it\\u2019s called, it returns the value of the expression that\\u2019s wrapped inside of it.\")), mdx(\"p\", null, \"but most importantly:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"An autoclosure lets you delay evaluation because the code inside isn\\u2019t run until you call the closure. Delaying evaluation is useful for code that has side effects or is computationally expensive because it lets you control when that code is evaluated.\")), mdx(\"p\", null, \"That means that the above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \" implementation at a high level is equivalent to the following. Note: We can\\u2019t actually write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \" without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rhs\"), \" since it\\u2019s defined to have both parameters.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"// For simplicity, I've removed all throws\\npublic static func && (lhs: Bool, rhs: () -> Bool) -> Bool {\\n    return lhs ?? rhs()\\n}\\n\\n// Example: Assume A and B are some boolean conditions\\nA && { () -> Bool in\\n    return B\\n}\\n\")), mdx(\"p\", null, \"If we update our previous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserTheme\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" with this re-interpretation, it would look like this\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"let result = self.user.isSubscribed && { () -> Bool in\\n    return self.user.countryCode == \\\"CA\\\"\\n}\\nif result {\\n    themeColor = self.user.themeColor\\n}\\n\")), mdx(\"p\", null, \"As you can see, the block captures \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self.user.countryCode == \\\"CA\\\"\"), \" and since we\\u2019re doing this before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"super.init()\"), \" when all members have initialized the compilation fails.\"), mdx(\"p\", null, \"There are a few ways to fix this, we could:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"move all this offending code to below the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"super.init()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"store the result of the right-hand side expression in a separate variable, or;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we could move the creation of Themes to a \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Factory_method_pattern\"\n  }), \"factory\"), \" class to avoid a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Theme\"), \" subclass\")), mdx(\"p\", null, \"Either way, these all work but in general you should typically avoid referencing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" before the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"super.init()\"), \" in cases like these.\\nI hope you learned something and potentially got you interested in looking at more implementation details of the Swift programming language.\"), mdx(\"p\", null, \"The sample code can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ajfigueroa/blog-code/tree/master/posts/3-Unexpected-Closure.playground\"\n  }), \"here\"), \".\"), mdx(\"h2\", {\n    \"id\": \"additional-resources\"\n  }, \"Additional Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID543\"\n  }), \"Autoclosure Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://krakendev.io/blog/hipster-swift#autoclosure\"\n  }), \"Hipster Swift post by KrakenDev\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/apple/swift\"\n  }), \"Swift Repo\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/unexpected-closure/","title":"Unexpected Closure","tags":[],"keywords":[],"date":"September 04, 2018"},"previous":null,"next":null},"pageContext":{"id":"4bbdc643-0779-5fd9-83e5-a9d7ee60b104"}}}